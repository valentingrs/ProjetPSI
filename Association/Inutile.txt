using Association;
using static Association.Program;

public string Afficher()
{
	string s = nom + " - { ";
	for (int i = 0; i < voisins.Count - 1; i++)
	{
		s = s + voisins[i] + ", ";
	}
	int j = voisins.Count - 1;
	s = s + voisins[j];
	return s;
}




Graphe association = LireFichier();
Console.WriteLine(association);

//parcours en largeur
Sommet depart = association.Sommets[0];
Console.WriteLine("Parcours en largeur à partir du sommet " + depart.Nom + ":");
association.ParcoursEnLargeur(depart);

//parcours en profondeur
Sommet depart2 = association.Sommets[0];
Console.WriteLine("\nParcours en profondeur à partir du sommet " + depart2.Nom + ":");
association.ParcoursEnProfondeur(depart2);

// Générer l'image du graphe
DessinerGraphe(association, "graphe.png");

// Afficher un message pour dire que l'image est générée
Console.WriteLine("L'image du graphe a été générée sous le nom 'graphe.png'.");



public void ParcoursEnLargeur(Sommet depart)
		{
			// Utilisation d'une file pour le parcours en largeur
			Queue<Sommet> file = new Queue<Sommet>();
			// Utilisation d'un dictionnaire pour garder une trace des sommets visités
			Dictionary<Sommet, bool> visite = new Dictionary<Sommet, bool>();

			// Initialisation
			foreach (Sommet sommet in sommets)
			{
				visite[sommet] = false;
			}

			// Marquer le sommet de départ comme visité et l'ajouter à la file
			visite[depart] = true;
			file.Enqueue(depart);

			// Parcours en largeur
			while (file.Count > 0)
			{
				Sommet sommetCourant = file.Dequeue();
				Console.Write(sommetCourant.Nom + " ");

				// Parcourir tous les voisins du sommet courant
				foreach (Sommet voisin in sommetCourant.Voisins)
				{
					if (visite.ContainsKey(voisin) && !visite[voisin])
					{
						visite[voisin] = true;
						file.Enqueue(voisin);
					}
				}
			}
		}

		public void ParcoursEnProfondeur(Sommet depart)
		{
			// Utilisation d'un dictionnaire pour garder une trace des sommets visités
			Dictionary<Sommet, bool> visite = new Dictionary<Sommet, bool>();

			// Initialisation
			foreach (Sommet sommet in sommets)
			{
				visite[sommet] = false;
			}

			// Appel récursif pour le parcours en profondeur
			ParcoursEnProfondeurRecursif(depart, visite);
		}

		private void ParcoursEnProfondeurRecursif(Sommet sommetCourant, Dictionary<Sommet, bool> visite)
		{
			// Marquer le sommet courant comme visité
			visite[sommetCourant] = true;
			Console.Write(sommetCourant.Nom + " ");

			// Parcourir tous les voisins du sommet courant
			foreach (Sommet voisin in sommetCourant.Voisins)
			{
				if (visite.ContainsKey(voisin) && !visite[voisin])
				{
					ParcoursEnProfondeurRecursif(voisin, visite);
				}
			}
		}



if (!listeAdj.ContainsKey(sommet))
				{
					listeAdj.Add(sommet, new List<Sommet>());
				}

				foreach (Sommet voisin in sommet.Voisins)
				{
					listeAdj[sommet].Add(voisin);

				}

static void TestGraphe()
        {
            Graphe graphe = new Graphe(true);
            Sommet A = new Sommet("A"); graphe.AjouterSommet(A);
            Sommet B = new Sommet("B"); graphe.AjouterSommet(B);
            Sommet C = new Sommet("C"); graphe.AjouterSommet(C);
            Lien lienAB = new Lien(A, B); graphe.AjouterLien(lienAB);

            Lien lienAC = new Lien(A, C); graphe.AjouterLien(lienAC);

            Lien lienCB = new Lien(C, B); graphe.AjouterLien(lienCB);

            Console.WriteLine(graphe);

            Dictionary<Sommet, List<Sommet>> listeAdj = graphe.ListeAdjacence();
            Sommet s = graphe.Sommets[0];
            Console.WriteLine(s + "\n");
            AfficherListe(s.Voisins);
            AfficherListe(listeAdj[s]);

        }
        static void TestGrapheOriente()
        {
            List<Sommet> sommets = new List<Sommet>();
            List<Lien> liens = new List<Lien>();
            Graphe graphe = new Graphe(true);
            Sommet A = new Sommet("A"); graphe.AjouterSommet(A);
            Sommet B = new Sommet("B"); graphe.AjouterSommet(B);
            Sommet C = new Sommet("C"); graphe.AjouterSommet(C);
            Sommet D = new Sommet("D"); graphe.AjouterSommet(D);
            Sommet E = new Sommet("E"); graphe.AjouterSommet(E);
            Sommet F = new Sommet("F"); graphe.AjouterSommet(F);
            Lien lienAB = new Lien(A, B); graphe.AjouterLien(lienAB);
            Lien lienAC = new Lien(A, C); graphe.AjouterLien(lienAC);
            Lien lienBD = new Lien(B, D); graphe.AjouterLien(lienBD);
            Lien lienCB = new Lien(C, B); graphe.AjouterLien(lienCB);
            Lien lienCD = new Lien(C, D); graphe.AjouterLien(lienCD);
            Lien lienDB = new Lien(D, B); graphe.AjouterLien(lienDB);
            Lien lienEF = new Lien(E, F); graphe.AjouterLien(lienEF);
            Lien lienFE = new Lien(F, E); graphe.AjouterLien(lienFE);
            Console.WriteLine(A);
            Console.WriteLine(E);
            Console.WriteLine(lienAB);
            Console.WriteLine("Graphe orienté : ");
            Console.WriteLine(graphe);
        }

        static void TestGrapheNonOriente()
        {
            List<Sommet> sommets = new List<Sommet>();
            List<Lien> liens = new List<Lien>();
            Graphe graphe = new Graphe(false);
            Sommet A = new Sommet("A"); graphe.AjouterSommet(A);
            Sommet B = new Sommet("B"); graphe.AjouterSommet(B);
            Sommet C = new Sommet("C"); graphe.AjouterSommet(C);
            Sommet D = new Sommet("D"); graphe.AjouterSommet(D);
            Sommet E = new Sommet("E"); graphe.AjouterSommet(E);
            Sommet F = new Sommet("F"); graphe.AjouterSommet(F);
            Lien lienAB = new Lien(A, B); graphe.AjouterLien(lienAB);
            Lien lienAC = new Lien(A, C); graphe.AjouterLien(lienAC);
            Lien lienBD = new Lien(B, D); graphe.AjouterLien(lienBD);
            Lien lienCB = new Lien(C, B); graphe.AjouterLien(lienCB);
            Lien lienCD = new Lien(C, D); graphe.AjouterLien(lienCD);
            Lien lienEF = new Lien(E, F); graphe.AjouterLien(lienEF);
            Lien lienFE = new Lien(F, E); graphe.AjouterLien(lienFE);
            Console.WriteLine("Graphe non orienté : ");
            Console.WriteLine(graphe);
        }


		static void DessinerGraphe(Graphe graphe, string fichierImage)
        {
            const int largeurImage = 800;
            const int hauteurImage = 600;

            // Création du bitmap pour l'image
            using (var bitmap = new SKBitmap(largeurImage, hauteurImage))
            using (var canvas = new SKCanvas(bitmap))
            {
                // Remplir le fond en blanc
                canvas.Clear(SKColors.White);

                // Créer un pinceau pour dessiner les liens
                SKPaint lienPaint = new SKPaint
                {
                    Color = SKColors.Black,
                    StrokeWidth = 2,
                    IsAntialias = true
                };

                // Créer un pinceau pour dessiner les sommets
                SKPaint sommetPaint = new SKPaint
                {
                    Color = SKColors.Blue,
                    IsAntialias = true,
                    Style = SKPaintStyle.Fill
                };

                // Créer un pinceau pour dessiner le texte des sommets
                SKPaint textPaint = new SKPaint
                {
                    Color = SKColors.Black,
                    TextSize = 30,
                    IsAntialias = true
                };

                // Position des sommets (un exemple simple)
                Dictionary<Sommet, SKPoint> positions = new Dictionary<Sommet, SKPoint>();
                int angleStep = 360 / graphe.Sommets.Count;
                int rayon = 200;
                SKPoint centre = new SKPoint(largeurImage / 2, hauteurImage / 2);
                int angle = 0;

                // Calculer les positions des sommets en cercle
                foreach (Sommet sommet in graphe.Sommets)
                {
                    float x = centre.X + rayon * (float)Math.Cos(Math.PI * angle / 180);
                    float y = centre.Y + rayon * (float)Math.Sin(Math.PI * angle / 180);
                    positions[sommet] = new SKPoint(x, y);
                    angle += angleStep;
                }

                // Dessiner les liens entre les sommets
                foreach (Lien lien in graphe.Liens)
                {
                    // Vérifier si les sommets existent dans le dictionnaire avant de dessiner
                    if (positions.ContainsKey(lien.Sommet1) && positions.ContainsKey(lien.Sommet2))
                    {
                        SKPoint point1 = positions[lien.Sommet1];
                        SKPoint point2 = positions[lien.Sommet2];
                        canvas.DrawLine(point1, point2, lienPaint);
                    }
                }

                // Dessiner les sommets
                foreach (KeyValuePair<Sommet, SKPoint> entry in positions)
                {
                    SKPoint position = entry.Value;
                    canvas.DrawCircle(position, 20, sommetPaint);  // Dessiner le sommet comme un cercle
                    canvas.DrawText(entry.Key.Nom, position.X - 10, position.Y + 10, textPaint);  // Dessiner le nom du sommet
                }

                // Sauvegarder l'image dans un fichier
                using (var image = SKImage.FromBitmap(bitmap))
                using (var data = image.Encode())
                using (var stream = File.OpenWrite(fichierImage))
                {
                    data.SaveTo(stream);
                }
            }
        }